<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>python ConfigParser模块详解 | Pyinx Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="ConfigParser,python,模块,配置文件," />
  

  <meta name="description" content="功能介绍&amp;nbsp;
 在程序中使用配置文件来灵活的配置一些参数是一件很常见的事情，配置文件的解析并不复杂，在python里更是如此，在官方发布的库中就包含有做这件事情的库，那就是ConfigParser，这里简单的做一些介绍。
ConfigParser解析的配置文件的格式比较象ini的配置文件格式，就是文件中由多个section构成，每个section下又有多个配置项。
&amp;nbsp;
方法介绍：">
<meta property="og:type" content="article">
<meta property="og:title" content="python ConfigParser模块详解">
<meta property="og:url" content="http://blog.itsir.org/2012/05/10/254/index.html">
<meta property="og:site_name" content="Pyinx Blog">
<meta property="og:description" content="功能介绍&amp;nbsp;
 在程序中使用配置文件来灵活的配置一些参数是一件很常见的事情，配置文件的解析并不复杂，在python里更是如此，在官方发布的库中就包含有做这件事情的库，那就是ConfigParser，这里简单的做一些介绍。
ConfigParser解析的配置文件的格式比较象ini的配置文件格式，就是文件中由多个section构成，每个section下又有多个配置项。
&amp;nbsp;
方法介绍：">
<meta property="og:updated_time" content="2015-08-06T02:38:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python ConfigParser模块详解">
<meta name="twitter:description" content="功能介绍&amp;nbsp;
 在程序中使用配置文件来灵活的配置一些参数是一件很常见的事情，配置文件的解析并不复杂，在python里更是如此，在官方发布的库中就包含有做这件事情的库，那就是ConfigParser，这里简单的做一些介绍。
ConfigParser解析的配置文件的格式比较象ini的配置文件格式，就是文件中由多个section构成，每个section下又有多个配置项。
&amp;nbsp;
方法介绍：">
  
  

  


  <link rel="stylesheet" href="/css/styles.css" type="text/css">
  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body>
  <div class="content-post">
  <a class="avatar" href="/archives">
    <img src="/images/avatar.jpg" alt="" />
  </a>
  <article id="post-254" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    <a class="post-title" href="/2012/05/10/254/">python ConfigParser模块详解</a>

  </header>

  <div class="article-meta">
    <span>2012-05-10</span>

    <span> | </span>

    <span class="article-author">pyinx</span>

    <span> | </span>

    
  <span class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </span>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="功能介绍"><span style="color: #00ff00;">功能介绍</span></h1><p>&nbsp;</p>
<pre><code> 在程序中使用配置文件来灵活的配置一些参数是一件很常见的事情，配置文件的解析并不复杂，在python里更是如此，在官方发布的库中就包含有做这件事情的库，那就是ConfigParser，这里简单的做一些介绍。
ConfigParser解析的配置文件的格式比较象ini的配置文件格式，就是文件中由多个<span class="built_in">section</span>构成，每个<span class="built_in">section</span>下又有多个配置项。
</code></pre><p>&nbsp;</p>
<h1 id="方法介绍："><span style="color: #00ff00;">方法介绍：</span></h1><p>&nbsp;</p>
<p><strong>Class RawConfigParser([defaults])</strong><br>基本配置类，当传递defaults时，会初始化到内置字典中。该类不支持智能修复，2.3版本新特征。</p>
<p><strong>Class ConfigParser([defaults])</strong><br>继承之RawConfigParser类，实现了智能特性，为get(),items()方法添加了可选参数。Defaults中的值必须能填补“%()s”。注意<strong>name</strong>是内置的default；该值是section的名称，它会被defaults提供的任何值所覆盖。</p>
<p>所以的用于填补的option名称都会通过optionxform()方法传递，就像其他任何option名称一样。例如，使用optionxform()的默认实现（将option名称转化成小写），“foo %(bar)s”和“foo %(BAR)s”的值相等。</p>
<p><strong>Class SafeConfigParser([defaults])</strong><br>继承至ConfigParser，实现了更多智能特征，实现更有可预见性，新的应用更偏好这个版本，如果他们不需要对python老版本的兼容性，2.3版本。</p>
<p><strong>Exception NoSectionError</strong><br>当没有发现给定section时抛出。</p>
<p><strong>Exception DuplicateSectionError</strong><br>如果add_section()方法被调用时，提供的section参数的值已经存在时抛出。</p>
<p><strong>Exception NoOptionError</strong><br>指定option不存在时抛出。</p>
<p><strong>Exception InterpolationError</strong><br>执行字符串填补时抛出的异常的基类。</p>
<p><strong>Exception InterpolationDepthError</strong><br>当填补字符串因为迭代次数超过了MAX_INTERPOLATION_DEPTH值时抛出的异常，InterpolationError的子类。</p>
<p><strong>Exception InterpolationMissingOptionError </strong><br>当option引用的值不存在时抛出，该异常为InterpolationError的子类，2.3版本新加。</p>
<p><strong>Exeption InterpolationSyntaxError</strong><br>当原文件格式没有遵守规定的语法时抛出的异常，继承至InterpolationError，2.3版本。</p>
<p><strong>Exception MissingSectionHeaderError</strong><br>尝试解析没有section头的文件时抛出。</p>
<p><strong>Exception ParsingError</strong><br>解析文件时发生错误。</p>
<p><strong>MAX_INTERPOLATION_DEPTH</strong><br>get()方法当raw参数为false时，递归的对大深度。只适用与ConfigParser类。</p>
<p>RawConfigParser对象</p>
<p>RawConfigParser实例的方法：</p>
<p><strong>defaults()</strong><br>返回全部示例中所以defaults。</p>
<p><strong>sections()</strong><br>返回有效的section列表，DEFAULT不包含在列表中。</p>
<p><strong>add_section(section)</strong><br>为实例添加一个section，如果给定的section名已经存在，将抛出DuplicateSectionError异常。</p>
<p><strong>has_section(section)</strong><br>判断给定的section名在配置文件中是否存在，DEFAULT section不包括。</p>
<p><strong>options(section)</strong><br>返回给定的section下的所有可用option的列表。</p>
<p><strong>has_option(section, option)</strong><br>如果section存在，并包含给定的option，返回true，放在返回false, 1.6版本新增。</p>
<p><strong>read(filenames)</strong><br>尝试解析文件列表，如果解析成功返回文件列表。如果filenames是string或Unicode string，将会按单个文件来解析。如果在filenames中的文件不能打开，该文件将被忽略。这样设计的目的是，让你能指定本地有可能是配置文件的列表（例如，当前文件夹，用户的根目录，及一些全系统目录），所以在列表中存在的配置文件都会被读取。如果文件都不存在，那么ConfigParser实例会包含空数据集。一个需要从配置文件读取初始化数据的应用程序，应该使用readfp()方法来加载所需要的文件，之后可以使用read()方法来获取任何可能的文件：</p>
<p>import ConfigParser, os config = ConfigParser.ConfigParser()config.readfp(open(‘defaults.cfg’)) config.read([‘site.cfg’, os.path.expanduser(‘~/.myapp.cfg’)])</p>
<p>2.4版本之后，返回成功解析的文件列表。</p>
<p><strong>readfp(fp[, filename])</strong><br>从文件或fp（值使用该对象的readline()方法）中的似文件类读取并解析配置数据，如果filename被省略，fp有一个name属性，该属性用于获取filename；默认是“&lt;???&gt;”。</p>
<p><strong>get(section, option)</strong><br>获取section下option的值。</p>
<p><strong>getint(section, option)</strong><br>强制指定section下的option的值，作为Int类型返回的方便方法。</p>
<p><strong>getfloat(section, option)</strong><br>强制section下的option值，作为float类型返回的方法方法。</p>
<p><strong>getboolean(section, option)</strong><br>强制section下的option值，作为布尔类型返回的方法方法。注意可接受的option的true值有“1”，“yes”，“true”及“on”，可接受的false值有“0”，“no”，“false”，“off”。字符串值不检测大小写，其他值会抛出ValueError异常。</p>
<p><strong>itmes(section)</strong><br>返回给定section下的所以option的（name, value）对列表。</p>
<p><strong>set(section, option, value)</strong><br>如果给定的setion存在，为option设定给定的值；否则抛出NoSectionError异常。当可能使用RawConfigParser（或者ConfigParser的参数raw为true）来在内部存储非字符串值，所以功能（包括填补和输出到文件）只能使用字符串值来归档。1.6版本新增。</p>
<p><strong>write(fileobject)</strong><br>将配置表示写入指定文件类，该表示以后可以通过调用read()来解析，1.6版本新增。</p>
<p><strong>remove_option(section, option)</strong><br>从指定section中删除指定option，如果section不存在，抛出NoSectionError异常；如果option存在，则删除，并返回True；否则返回false。1.6版本新增。</p>
<p><strong>remove_section(section)</strong><br>从配置文件中删除指定的section，如果section确实存在，返回true，否则返回false。</p>
<p><strong>optionxform(option)</strong><br>将输入文件中，或客户端代码传递的option名转化成内部结构使用的形式。默认实现返回option的小写形式；子类可能重写该方法或客户端代码可能将该方法作为实例的属性，以此来影响它的行为。将此用于str()，例如，会使option名称大小写敏感。</p>
<p>ConfigParser对象</p>
<p>ConfigParser类扩展了RawConfigParser的一些接口方法，添加了一些可选参数。</p>
<p><strong>get(section, option [, raw[, vars]])</strong><br>获取给定section下的option的值，所以“%”占位符在返回值中被填补，基于构造时传递的默认值，就像option，vars也被提供，除非raw参数为true。</p>
<p><strong>items(section, [, raw[, vars]])</strong><br>返回给定section下的所以option的（name, value）对列表。可选参数同get方法，2.3版本新增。</p>
<p>SafeConfigParser对象</p>
<p>SafeConfigParser类实现了ConfigParser相同的接口，新增如下方法：</p>
<p><strong>set(section, option, value)</strong><br>如果给定的section存在，给option赋值；否则抛出NoSectionError异常。Value值必须是字符串（str或unicode）；如果不是，抛出TypeError异常，2.4版本新增。</p>
<p>&nbsp;</p>
<h1 id="实际应用："><span style="color: #00ff00;">实际应用：</span></h1><p>&nbsp;</p>
<p>比如：</p>
<p>[db]<br>db_host=127.0.0.1<br>db_port=3306<br>db_user=root<br>db_pass=password<br>[concurrent]<br>thread=10<br>processor=20</p>
<pre><code>假设上面的配置文件的名字为<span class="keyword">test</span>.<span class="keyword">conf</span>。里面包含两个section,一个是<span class="keyword">db</span>, 另一个是concurrent, <span class="keyword">db</span>里面还包含有4项，concurrent里面有两项。这里来做做解析：
</code></pre><p><div></div></p>
<p><div>#-<em>- encoding: gb2312 -</em>-<br>import ConfigParser<br>import string, os, syscf = ConfigParser.ConfigParser()<br>cf.read(“test.conf”)</div></p>
<h1 id="返回所有的section">返回所有的section</h1><p>s = cf.sections()<br>print ‘section:’, s</p>
<p>o = cf.options(“db”)<br>print ‘options:’, o</p>
<p>v = cf.items(“db”)<br>print ‘db:’, v</p>
<p>print ‘-‘*60</p>
<p>#可以按照类型读取出来<br>db_host = cf.get(“db”, “db_host”)<br>db_port = cf.getint(“db”, “db_port”)<br>db_user = cf.get(“db”, “db_user”)<br>db_pass = cf.get(“db”, “db_pass”)</p>
<h1 id="返回的是整型的">返回的是整型的</h1><p>threads = cf.getint(“concurrent”, “thread”)<br>processors = cf.getint(“concurrent”, “processor”)</p>
<p>print “db_host:”, db_host<br>print “db_port:”, db_port<br>print “db_user:”, db_user<br>print “db_pass:”, db_pass</p>
<p>print “thread:”, threads<br>print “processor:”, processors</p>
<p>#修改一个值，再写回去<br>cf.set(“db”, “db_pass”, “zhaowei”)</p>
<p><br><br>&nbsp;</p>

      
    </div>

    
      

    

  </div>
</article>



<section class="disqus-comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>




</div>

  
<script>
  var disqus_shortname = 'pyinx';
  
  var disqus_url = 'http://blog.itsir.org/2012/05/10/254/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"undefined"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0]
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!-- 多说公共JS代码 end -->

</body>
</html>
